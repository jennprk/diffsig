chains = 4,             # number of Markov chains
warmup = 1000,          # number of warmup iterations per chain
iter = 2000,            # total number of iterations per chain
cores = 4,              # number of cores (could use one per chain)
refresh = 1000,             # no progress shown
verbose = T
)
library(rstan)
fit <- stan(
file = "./inst/stan/diffsig.stan",  # Stan program
data = list(K=K,M=M,L=96,Y=simdat$Y,N=N,C=C_K,X=simdat$X, beta_sd=0.5),
include = T,
pars = c("beta"),
chains = 4,             # number of Markov chains
warmup = 1000,          # number of warmup iterations per chain
iter = 2000,            # total number of iterations per chain
cores = 4,              # number of cores (could use one per chain)
refresh = 1000,             # no progress shown
verbose = T
)
M=nrow(X)
M=nrow(simdat$X)
fit <- stan(
file = "./inst/stan/diffsig.stan",  # Stan program
data = list(K=K,M=M,L=96,Y=simdat$Y,N=N,C=C_K,X=simdat$X, beta_sd=0.5),
include = T,
pars = c("beta"),
chains = 4,             # number of Markov chains
warmup = 1000,          # number of warmup iterations per chain
iter = 2000,            # total number of iterations per chain
cores = 4,              # number of cores (could use one per chain)
refresh = 1000,             # no progress shown
verbose = T
)
mu_tau_summary <- summary(fit, pars = c("beta"), probs = c(0.1, 0.9))$summary
data.frame(Rhat =mu_tau_summary[,"Rhat"])
rstan::traceplot(fit)
rstan::traceplot(fit, pars="beta")
diffsig_eval(truebeta = truebeta, fit = fit, credibleInterval = 80)
#' Diffsig coverage and root mean squared error (RMSE) calculation function
#'
#' @export
#' @param truebeta a vector of true betas
#' @param fit a `stanfit` object returned by `rstan::stan`
#' @param coverage a 2-dimension vector of lower/upper credible interval
#' @param beta_sd standard deviation for sampling hyperparameter beta
#' @param ... Arguments passed to `rstan::stan` (e.g. thin, init, ...).
#' @return An object of class `stanfit` returned by `rstan::stan`
#'
diffsig_eval <- function(truebeta, fit, credibleInterval=80, include = T, ...) {
if (class(fit)!="stanfit") {
stop("fit has to be a stanfit object from rstan package")
}
truebeta = c(t(simdat$truebeta))
CI_low = (100-credibleInterval)/2/100
CI_up = 1-CI_low
estimate= c()
for (i in 1:length(truebeta)) {
estimate= rbind(estimate,summary(fit, pars="beta", probs=c(CI_low,CI_up))$summary[i,c(1,4,5)])
}
estimate = as.data.frame(cbind(truebeta,estimate))
colnames(estimate) = c("truebeta","estimate","min","max")
for (i in 1:length(truebeta)) {
estimate$contain[i] = estimate[i,"truebeta"] > estimate[i,"min"] && estimate[i,"truebeta"] < estimate[i,"max"]
estimate$rmse[i] = sqrt(mean((estimate$truebeta[i] - estimate$estimate[i])^2))
}
colnames(estimate) = c("truebeta","estimate","10%","90%","contain","rmse")
return(list(estimate, perc_coverage=mean(estimate$contain), mean_rmse=mean(estimate$rmse)))
}
diffsig_eval(truebeta = truebeta, fit = fit, credibleInterval = 80)
simdat = simdat_gen(N=N, K=K, truetau=truetau, C=C_K,
continuous=2, binary=NA, categorical=NA, cat_levels=NA, seed=123)
fit <- stan(
file = "./inst/stan/diffsig.stan",  # Stan program
data = list(K=K,M=M,L=96,Y=simdat$Y,N=N,C=C_K,X=simdat$X, beta_sd=0.5),
include = T,
pars = c("beta"),
chains = 4,             # number of Markov chains
warmup = 1000,          # number of warmup iterations per chain
iter = 2000,            # total number of iterations per chain
cores = 4,              # number of cores (could use one per chain)
refresh = 1000,             # no progress shown
verbose = T
)
fit <- stan(
file = "./inst/stan/diffsig.stan",  # Stan program
data = list(K=K,M=M,L=96,Y=simdat$Y,N=N,C=C_K,X=simdat$X, beta_sd=0.5),
include = T,
pars = c("beta"),
chains = 4,             # number of Markov chains
warmup = 1000,          # number of warmup iterations per chain
iter = 2000,            # total number of iterations per chain
cores = 4,              # number of cores (could use one per chain)
refresh = 1000,             # no progress shown
verbose = T,
)
fit <- stan(
file = "./inst/stan/diffsig.stan",  # Stan program
data = list(K=K,M=M,L=96,Y=simdat$Y,N=N,C=C_K,X=simdat$X, beta_sd=0.5),
include = T,
pars = c("beta"),
chains = 4,             # number of Markov chains
warmup = 1000,          # number of warmup iterations per chain
iter = 2000,            # total number of iterations per chain
cores = 4,              # number of cores (could use one per chain)
refresh = 1000,             # no progress shown
verbose = T, seed=123
)
(eval_res = diffsig_eval(truebeta = truebeta, fit = fit, credibleInterval = 80))
round(eval_res$perc_coverage,2)*100
round(eval_res$mean_rmse,2)
mu_tau_summary <- summary(fit, pars = c("beta"), probs = c(0.1, 0.9))$summary
data.frame(Rhat =mu_tau_summary[,"Rhat"])
hildaDiffPlot
HiLDA::hildaDiffPlot
stan_plot
#'
#' @export
#' @param fit stan fit object from diffsig_stan
#' @param pars parameters to plot
#' @param M parameters to plot
#' @param riskfactors labels for each risk factor including intercept
#' @param rowlabels labels for betas in diffsig plot
#' @param ... Arguments passed to ggplot
#' @return Diffsig plot
#'
diffsig_plot <- function(fit, pars, rowlabels, rowgroup=NULL, est_color=NULL, colors=NULL) {
require(rstan, quietly = T)
require(viridis, quietly = T)
statmat <- summary(fit)$summary[,c("mean","2.5%", "25%", "50%", "75%", "97.5%")]
statmat <- as.data.frame(statmat[pars,])
statmat$group <- factor(rowgroup, levels=unique(rowgroup))
y <- as.numeric(seq(length(pars), 1, by = -1))
xlim.use <- c(min(statmat[, 2L]), max(statmat[, 6L]))
xlim.use <- xlim.use + diff(xlim.use) * c(-0.05, 0.05)
xy.df <- data.frame(params = rownames(statmat), y, statmat)
colnames(xy.df) <- c("params", "y", "mean", "ll", "l", "m", "h", "hh")
p.base <- ggplot2::ggplot(xy.df)
p.name <- ggplot2::scale_y_continuous(breaks = y, labels = rowlabels,
limits = c(0.8, max(y) + 0.2))
p.all <- p.base + ggplot2::xlim(xlim.use) + p.name + geom_vline(xintercept=0, linetype="dashed",color="darkgrey") +
theme_bw()
p.ci <- ggplot2::geom_segment(mapping = ggplot2::aes_string(x = "ll", xend = "hh", y = "y", yend = "y"))
p.all <- p.all + p.ci
if(is.null(est_color)) {
est_color <- "#FFC20A"
}
if(is.null(rowgroup)) {
if(length(colors)!=1) {
stop("If no rowgroup is provided, only one color should be specified or use default.")
}
if(is.null(colors)) {
color_by <- "#0C7BDC"
}
p.ci.2 <- ggplot2::geom_segment(ggplot2::aes_string(x = "l", xend = "h", y = "y", yend = "y"), color = color_by, size = 2)
p.point <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y"), shape = 19, color=color_by, size = 2, show.legend = F)
p.point2 <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y"), shape = 19, color=est_color, size = 1.5)
p.all <- p.all + p.ci.2 +
xlab(expression(beta)) +
theme(axis.title.y=element_blank())
} else {
color_by <- "statmat$group"
p.ci.2 <- ggplot2::geom_segment(ggplot2::aes_string(x = "l", xend = "h", y = "y", yend = "y", color = color_by), size = 2)
p.point <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y", color=color_by), shape = 19, size = 2, show.legend = F)
p.point2 <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y"), color = est_color, shape = 19, size = 1.5)
if(is.null(colors)) {
p.all <- p.all +
p.ci.2 +
scale_color_viridis(discrete = TRUE, begin = 0.8, end=0.2, option="A", name="Risk Factors") +
xlab(expression(beta)) +
theme(axis.title.y=element_blank())
} else {
if(length(colors)!=length(unique(rowgroup))) {
stop("Length of colors should match the number of unique groups in rowgroup")
}
p.all <- p.all +
p.ci.2 +
scale_color_manual(name="Risk Factors",values=colors) +
xlab(expression(beta)) +
theme(axis.title.y=element_blank())
}
}
p <- p.all + p.point +  p.point2
(p <- p +
theme(legend.position="bottom",
panel.grid.minor.y = element_blank(),
panel.grid.minor.x = element_line(size = 0.05),
axis.title.y = element_blank()) +
# scale_x_continuous(breaks=ggbld$layout$panel_params[[1]]$x.sec$breaks,
# labels=c("less common",ggbld$layout$panel_params[[1]]$x.sec$breaks[-c(1, length(ggbld$layout$panel_params[[1]]$x.sec$breaks))], "more common")) +
# scale_x_continuous(breaks = c(layer_scales(p)$x$range$range[1],ggbld$layout$panel_params[[1]]$x.sec$breaks,layer_scales(p)$x$range$range[2]),
# labels = c("Less Common",ggbld$layout$panel_params[[1]]$x.sec$breaks,"More Common")) +
theme(axis.ticks.x = element_blank(),
axis.ticks.y = element_blank(),
axis.line.x = element_line(arrow = grid::arrow(length = unit(0.3, "cm"),
ends = "both"), color="grey27"),
axis.title.x = element_text(angle = 0, hjust=1,margin = margin(t = -2, r = 0, b = 0, l = 0)),
axis.text.x = element_text(size="10"),
panel.grid.major.x = element_line(),
plot.margin = margin(t = 5,  # Top margin
r = 30,  # Right margin
b = 5,  # Bottom margin
l = 5),
panel.border = element_blank(),
legend.margin = margin(t=-15))+
# legend.spacing.x = unit(0.1, 'cm')) +
guides(colour = guide_legend(ncol = 3))
)
# pp = ggplot_build(p)
# ## re-label y-axis with names
# pp$layout$panel_params[[1]]$y.sec$scale$labels <- rowlabels
# ppp <- ggplot_gtable(pp)
# p_fin <- as.ggplot(ppp)
return(p)
}
diffsig_plot(fit,pars="beta",
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5))
fit
diffsig_plot(fit,pars=1:10,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5))
diffsig_plot(fit,pars=10,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5))
diffsig_plot(fit,pars=1:10,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5))
diffsig_plot(fit,pars=1:15,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5))
names(fit)
names(fit)[pars]
pars=1:15
names(fit)[pars]
ci_level=80,
ci_low = (100-ci_level)/2/100
ci_level=80
ci_low = (100-ci_level)/2*100
ci_up = 1-CI_low
ci_low = (100-ci_level)/2/100
ci_up = 1-CI_low
ci_up = 1-ci_low
statmat <- summary(fit, probs=c(ci_low,ci_up))$summary[,c("mean","2.5%", "25%", "50%", "75%", "97.5%")]
statmat <- summary(fit, probs=c(ci_low,ci_up))$summary[,c("mean","10%", "25%", "50%", "75%", "90%")]
summary(fit, probs=c(ci_low,ci_up))$summary
statmat <- summary(fit, probs=c(ci_low,0.25,0.5,0.75,ci_up))$summary[,c("mean","10%", "25%", "50%", "75%", "90%")]
statmat <- as.data.frame(statmat[names(fit)[pars],])
statmat
rowgroup = rep(c("intercept","cont1","cont2"),each=5)
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3)
statmat$group <- factor(rowgroup, levels=unique(rowgroup))
y <- as.numeric(seq(length(pars), 1, by = -1))
#'
#' @export
#' @param fit stan fit object from diffsig_stan
#' @param pars parameters to plot
#' @param M parameters to plot
#' @param riskfactors labels for each risk factor including intercept
#' @param rowlabels labels for betas in diffsig plot
#' @param ... Arguments passed to ggplot
#' @return Diffsig plot
#'
diffsig_plot <- function(fit, pars, ci_level=80, rowlabels, rowgroup=NULL, est_color=NULL, colors=NULL) {
require(rstan, quietly = T)
require(viridis, quietly = T)
ci_low = (100-ci_level)/2/100
ci_up = 1-ci_low
statmat <- summary(fit, probs=c(ci_low,0.25,0.5,0.75,ci_up))$summary[,c("mean","10%", "25%", "50%", "75%", "90%")]
statmat <- as.data.frame(statmat[names(fit)[pars],])
statmat$group <- factor(rowgroup, levels=unique(rowgroup))
y <- as.numeric(seq(length(pars), 1, by = -1))
xlim.use <- c(min(statmat[, 2L]), max(statmat[, 6L]))
xlim.use <- xlim.use + diff(xlim.use) * c(-0.05, 0.05)
xy.df <- data.frame(params = rownames(statmat), y, statmat)
colnames(xy.df) <- c("params", "y", "mean", "ll", "l", "m", "h", "hh")
p.base <- ggplot2::ggplot(xy.df)
p.name <- ggplot2::scale_y_continuous(breaks = y, labels = rowlabels,
limits = c(0.8, max(y) + 0.2))
p.all <- p.base + ggplot2::xlim(xlim.use) + p.name + geom_vline(xintercept=0, linetype="dashed",color="darkgrey") +
theme_bw()
p.ci <- ggplot2::geom_segment(mapping = ggplot2::aes_string(x = "ll", xend = "hh", y = "y", yend = "y"))
p.all <- p.all + p.ci
if(is.null(est_color)) {
est_color <- "#FFC20A"
}
if(is.null(rowgroup)) {
if(length(colors)!=1) {
stop("If no rowgroup is provided, only one color should be specified or use default.")
}
if(is.null(colors)) {
color_by <- "#0C7BDC"
}
p.ci.2 <- ggplot2::geom_segment(ggplot2::aes_string(x = "l", xend = "h", y = "y", yend = "y"), color = color_by, size = 2)
p.point <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y"), shape = 19, color=color_by, size = 2, show.legend = F)
p.point2 <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y"), shape = 19, color=est_color, size = 1.5)
p.all <- p.all + p.ci.2 +
xlab(expression(beta)) +
theme(axis.title.y=element_blank())
} else {
color_by <- "statmat$group"
p.ci.2 <- ggplot2::geom_segment(ggplot2::aes_string(x = "l", xend = "h", y = "y", yend = "y", color = color_by), size = 2)
p.point <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y", color=color_by), shape = 19, size = 2, show.legend = F)
p.point2 <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y"), color = est_color, shape = 19, size = 1.5)
if(is.null(colors)) {
p.all <- p.all +
p.ci.2 +
scale_color_viridis(discrete = TRUE, begin = 0.8, end=0.2, option="A", name="Risk Factors") +
xlab(expression(beta)) +
theme(axis.title.y=element_blank())
} else {
if(length(colors)!=length(unique(rowgroup))) {
stop("Length of colors should match the number of unique groups in rowgroup")
}
p.all <- p.all +
p.ci.2 +
scale_color_manual(name="Risk Factors",values=colors) +
xlab(expression(beta)) +
theme(axis.title.y=element_blank())
}
}
p <- p.all + p.point +  p.point2
(p <- p +
theme(legend.position="bottom",
panel.grid.minor.y = element_blank(),
panel.grid.minor.x = element_line(size = 0.05),
axis.title.y = element_blank()) +
# scale_x_continuous(breaks=ggbld$layout$panel_params[[1]]$x.sec$breaks,
# labels=c("less common",ggbld$layout$panel_params[[1]]$x.sec$breaks[-c(1, length(ggbld$layout$panel_params[[1]]$x.sec$breaks))], "more common")) +
# scale_x_continuous(breaks = c(layer_scales(p)$x$range$range[1],ggbld$layout$panel_params[[1]]$x.sec$breaks,layer_scales(p)$x$range$range[2]),
# labels = c("Less Common",ggbld$layout$panel_params[[1]]$x.sec$breaks,"More Common")) +
theme(axis.ticks.x = element_blank(),
axis.ticks.y = element_blank(),
axis.line.x = element_line(arrow = grid::arrow(length = unit(0.3, "cm"),
ends = "both"), color="grey27"),
axis.title.x = element_text(angle = 0, hjust=1,margin = margin(t = -2, r = 0, b = 0, l = 0)),
axis.text.x = element_text(size="10"),
panel.grid.major.x = element_line(),
plot.margin = margin(t = 5,  # Top margin
r = 30,  # Right margin
b = 5,  # Bottom margin
l = 5),
panel.border = element_blank(),
legend.margin = margin(t=-15))+
# legend.spacing.x = unit(0.1, 'cm')) +
guides(colour = guide_legend(ncol = 3))
)
# pp = ggplot_build(p)
# ## re-label y-axis with names
# pp$layout$panel_params[[1]]$y.sec$scale$labels <- rowlabels
# ppp <- ggplot_gtable(pp)
# p_fin <- as.ggplot(ppp)
return(p)
}
diffsig_plot(fit,pars=1:15,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5))
#'
#' @export
#' @param fit stan fit object from diffsig_stan
#' @param pars parameters to plot
#' @param M parameters to plot
#' @param riskfactors labels for each risk factor including intercept
#' @param rowlabels labels for betas in diffsig plot
#' @param ... Arguments passed to ggplot
#' @return Diffsig plot
#'
diffsig_plot <- function(fit, pars, ci_level=80, rowlabels, rowgroup=NULL, est_color=NULL, colors=NULL) {
require(rstan, quietly = T)
require(viridis, quietly = T)
if(!is.null(colors)) {
if(length(unique(rowgroup))!=length(colors)) {
warning("Number of colors does not match the number of unique groups from rowgroup")
}
}
if(!is.null(est_color)) {
if(length(est_color)!=1) {
stop("Only 1 color can be specified for the estimation point est_color")
}
}
ci_low = (100-ci_level)/2/100
ci_up = 1-ci_low
statmat <- summary(fit, probs=c(ci_low,0.25,0.5,0.75,ci_up))$summary[,c("mean","10%", "25%", "50%", "75%", "90%")]
statmat <- as.data.frame(statmat[names(fit)[pars],])
statmat$group <- factor(rowgroup, levels=unique(rowgroup))
y <- as.numeric(seq(length(pars), 1, by = -1))
xlim.use <- c(min(statmat[, 2L]), max(statmat[, 6L]))
xlim.use <- xlim.use + diff(xlim.use) * c(-0.05, 0.05)
xy.df <- data.frame(params = rownames(statmat), y, statmat)
colnames(xy.df) <- c("params", "y", "mean", "ll", "l", "m", "h", "hh")
p.base <- ggplot2::ggplot(xy.df)
p.name <- ggplot2::scale_y_continuous(breaks = y, labels = rowlabels,
limits = c(0.8, max(y) + 0.2))
p.all <- p.base + ggplot2::xlim(xlim.use) + p.name + geom_vline(xintercept=0, linetype="dashed",color="darkgrey") +
theme_bw()
p.ci <- ggplot2::geom_segment(mapping = ggplot2::aes_string(x = "ll", xend = "hh", y = "y", yend = "y"))
p.all <- p.all + p.ci
if(is.null(est_color)) {
est_color <- "#FFC20A"
}
if(is.null(rowgroup)) {
if(length(colors)!=1) {
stop("If no rowgroup is provided, only one color should be specified or use default.")
}
if(is.null(colors)) {
color_by <- "#0C7BDC"
}
p.ci.2 <- ggplot2::geom_segment(ggplot2::aes_string(x = "l", xend = "h", y = "y", yend = "y"), color = color_by, size = 2)
p.point <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y"), shape = 19, color=color_by, size = 2, show.legend = F)
p.point2 <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y"), shape = 19, color=est_color, size = 1.5)
p.all <- p.all + p.ci.2 +
xlab(expression(beta)) +
theme(axis.title.y=element_blank())
} else {
color_by <- "statmat$group"
p.ci.2 <- ggplot2::geom_segment(ggplot2::aes_string(x = "l", xend = "h", y = "y", yend = "y", color = color_by), size = 2)
p.point <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y", color=color_by), shape = 19, size = 2, show.legend = F)
p.point2 <- ggplot2::geom_point(ggplot2::aes_string(x = "m", y = "y"), color = est_color, shape = 19, size = 1.5)
if(is.null(colors)) {
p.all <- p.all +
p.ci.2 +
scale_color_viridis(discrete = TRUE, begin = 0.8, end=0.2, option="A", name="Risk Factors") +
xlab(expression(beta)) +
theme(axis.title.y=element_blank())
} else {
if(length(colors)!=length(unique(rowgroup))) {
stop("Length of colors should match the number of unique groups in rowgroup")
}
p.all <- p.all +
p.ci.2 +
scale_color_manual(name="Risk Factors",values=colors) +
xlab(expression(beta)) +
theme(axis.title.y=element_blank())
}
}
p <- p.all + p.point +  p.point2
(p <- p +
theme(legend.position="bottom",
panel.grid.minor.y = element_blank(),
panel.grid.minor.x = element_line(size = 0.05),
axis.title.y = element_blank()) +
# scale_x_continuous(breaks=ggbld$layout$panel_params[[1]]$x.sec$breaks,
# labels=c("less common",ggbld$layout$panel_params[[1]]$x.sec$breaks[-c(1, length(ggbld$layout$panel_params[[1]]$x.sec$breaks))], "more common")) +
# scale_x_continuous(breaks = c(layer_scales(p)$x$range$range[1],ggbld$layout$panel_params[[1]]$x.sec$breaks,layer_scales(p)$x$range$range[2]),
# labels = c("Less Common",ggbld$layout$panel_params[[1]]$x.sec$breaks,"More Common")) +
theme(axis.ticks.x = element_blank(),
axis.ticks.y = element_blank(),
axis.line.x = element_line(arrow = grid::arrow(length = unit(0.3, "cm"),
ends = "both"), color="grey27"),
axis.title.x = element_text(angle = 0, hjust=1,margin = margin(t = -2, r = 0, b = 0, l = 0)),
axis.text.x = element_text(size="10"),
panel.grid.major.x = element_line(),
plot.margin = margin(t = 5,  # Top margin
r = 30,  # Right margin
b = 5,  # Bottom margin
l = 5),
panel.border = element_blank(),
legend.margin = margin(t=-15))+
# legend.spacing.x = unit(0.1, 'cm')) +
guides(colour = guide_legend(ncol = 3))
)
# pp = ggplot_build(p)
# ## re-label y-axis with names
# pp$layout$panel_params[[1]]$y.sec$scale$labels <- rowlabels
# ppp <- ggplot_gtable(pp)
# p_fin <- as.ggplot(ppp)
return(p)
}
diffsig_plot(fit, pars=1:15, ci_level = 80,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5),
colors=c("#D81B60","#1E88E5","#FFC107"))
diffsig_plot(fit, pars=1:15, ci_level = 80,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5),
colors=c("#D81B60","#1E88E5","#FFC107"),
est_color="#1D1C1A")
diffsig_plot(fit, pars=1:15, ci_level = 80,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5),
colors=c("#D81B60","#1E88E5","#FFC107"),
est_color="#F5F3EF")
diffsig_plot(fit, pars=1:15, ci_level = 80,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5),
colors=c("#D81B60","#1E88E5","#FFC107"),
est_color="#F5F3EF") +
geom_point(aes(y=1:15,x=truebeta))
diffsig_plot(fit, pars=1:15, ci_level = 80,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5),
colors=c("#D81B60","#1E88E5","#FFC107"),
est_color="#F5F3EF") +
geom_point(aes(y=1:15,x=simdat$truebeta))
diffsig_plot(fit, pars=1:15, ci_level = 80,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5),
colors=c("#D81B60","#1E88E5","#FFC107"),
est_color="#F5F3EF") +
geom_point(aes(y=1:15,x=simdat$truebeta),shape=3)
diffsig_plot(fit, pars=1:15, ci_level = 80,
rowlabels = rep(c("SBS2","SBS3","SBS5","SBS8","SBS13"),3),
rowgroup = rep(c("intercept","cont1","cont2"),each=5),
colors=c("#D81B60","#1E88E5","#FFC107"),
est_color="#F5F3EF") +
geom_point(aes(y=15:1,x=simdat$truebeta),shape=3)
install.packages('Seurat')
library(Seurat)
?merge_maf
merge_mafs
library(maftools)
merge_mafs
